use std::{fmt::Display, future::Future, process::Output};

use chrono::{DateTime, Duration, Local};
pub use engine_traits::SstCompressionType;
use external_storage::FullFeaturedStorage;
use tokio::{io::AsyncWriteExt, runtime::Handle, signal::unix::SignalKind};
use txn_types::TimeStamp;

use crate::{
    compaction::{Subcompaction, SubcompactionResult},
    errors::Result,
    execute::Execution,
    statistic::{CollectCompactionStatistic, CompactStatistic, LoadMetaStatistic, LoadStatistic},
};

pub struct NoHooks;

impl ExecHooks for NoHooks {}

#[derive(PartialEq, Eq, Debug, Clone, Copy)]
pub struct CId(pub u64);

impl std::fmt::Display for CId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

#[derive(Clone, Copy)]
pub struct BeforeStartCtx<'a> {
    pub async_rt: &'a Handle,
    pub est_meta_size: u64,
    pub this: &'a Execution,
}

#[derive(Clone)]
pub struct AfterFinishCtx<'a> {
    pub async_rt: Handle,
    pub comments: String,
    pub external_storage: &'a dyn FullFeaturedStorage,
}

pub struct CompactionFinishCtx<'a> {
    pub external_storage: &'a dyn FullFeaturedStorage,
    pub result: &'a SubcompactionResult,
}

pub trait ExecHooks: 'static {
    fn before_a_compaction_start(&mut self, _cid: CId, _c: &Subcompaction) {}
    fn after_a_compaction_end<'a>(
        &'a mut self,
        _cid: CId,
        _res: &'a mut CompactionFinishCtx<'a>,
    ) -> impl Future<Output = Result<()>> + 'a {
        futures::future::ok(())
    }

    fn before_execution_started(&mut self, _cx: BeforeStartCtx<'_>) {}
    fn after_execution_finished<'a>(
        &'a mut self,
        _cx: &'a mut AfterFinishCtx<'a>,
    ) -> impl Future<Output = Result<()>> + 'a {
        futures::future::ok(())
    }

    fn update_load_meta_stat(&mut self, _stat: &LoadMetaStatistic) {}
    fn update_collect_compaction_stat(&mut self, _stat: &CollectCompactionStatistic) {}

    fn comments(&self) -> impl Display + '_ {
        ""
    }
}

impl<T: ExecHooks, U: ExecHooks> ExecHooks for (T, U) {
    fn before_a_compaction_start(&mut self, cid: CId, c: &Subcompaction) {
        self.0.before_a_compaction_start(cid, c);
        self.1.before_a_compaction_start(cid, c);
    }

    fn after_a_compaction_end<'a>(
        &'a mut self,
        cid: CId,
        cx: &'a mut CompactionFinishCtx<'a>,
    ) -> impl Future<Output = Result<()>> + 'a {
        async move {
            let cx = cx as *mut _;
            // SAFETY: After the future generated by `self.0` resolved, it won't access
            // `&mut cx` anymore.
            // The unsafe is needed here, because the `'a` lifetime for `&mut cx` is too
            // long. But we cannot reduce its lifetime in the signature or we are not
            // allowed to use it in the returned future...
            self.0
                .after_a_compaction_end(
                    cid,
                    // This arg was derived to be `&'a mut`... But it can have a shorter
                    // lifetime...
                    unsafe { &mut *cx },
                )
                .await?;
            self.1
                .after_a_compaction_end(cid, unsafe { &mut *cx })
                .await?;
            Ok(())
        }
    }

    fn before_execution_started(&mut self, cx: BeforeStartCtx<'_>) {
        self.0.before_execution_started(cx);
        self.1.before_execution_started(cx);
    }

    fn after_execution_finished<'a>(
        &'a mut self,
        cx: &'a mut AfterFinishCtx<'a>,
    ) -> impl Future<Output = Result<()>> + 'a {
        async {
            let cx = cx as *mut _;
            // SAFETY: see `after_a_compaction_end`.
            self.0.after_execution_finished(unsafe { &mut *cx }).await?;
            self.1.after_execution_finished(unsafe { &mut *cx }).await?;
            Ok(())
        }
    }

    fn update_load_meta_stat(&mut self, stat: &LoadMetaStatistic) {
        self.0.update_load_meta_stat(stat);
        self.1.update_load_meta_stat(stat);
    }

    fn update_collect_compaction_stat(&mut self, stat: &CollectCompactionStatistic) {
        self.0.update_collect_compaction_stat(stat);
        self.1.update_collect_compaction_stat(stat);
    }

    fn comments(&self) -> impl Display + '_ {
        format!("{} <> {}", self.0.comments(), self.1.comments())
    }
}

#[derive(Default)]
pub struct LogToTerm {
    load_stat: LoadStatistic,
    compact_stat: CompactStatistic,
    load_meta_stat: LoadMetaStatistic,
    collect_stat: CollectCompactionStatistic,
    begin: Option<DateTime<Local>>,
    meta_len: u64,
}

impl ExecHooks for LogToTerm {
    fn before_a_compaction_start(&mut self, cid: CId, c: &Subcompaction) {
        println!(
            "[{}] spawning compaction. cid: {}, cf: {}, input_min_ts: {}, input_max_ts: {}, source: {}, size: {}, region_id: {}",
            TimeStamp::physical_now(),
            cid.0,
            c.cf,
            c.input_min_ts,
            c.input_max_ts,
            c.inputs.len(),
            c.size,
            c.region_id
        );
    }

    fn after_a_compaction_end<'a>(
        &'a mut self,
        cid: CId,
        cx: &'a mut CompactionFinishCtx<'a>,
    ) -> impl Future<Output = Result<()>> + 'a {
        let lst = &cx.result.load_stat;
        let cst = &cx.result.compact_stat;
        let logical_input_size = lst.logical_key_bytes_in + lst.logical_value_bytes_in;
        let total_take =
            cst.load_duration + cst.sort_duration + cst.save_duration + cst.write_sst_duration;
        let speed = logical_input_size as f64 / total_take.as_millis() as f64;
        self.load_stat += lst.clone();
        self.compact_stat += cst.clone();

        println!(
            "[{}] finishing compaction. meta: {}/{}, p_bytes: {}, cid: {}, load_stat: {:?}, compact_stat: {:?}, speed: {:.2} KB./s, total_take: {:?}, global_load_meta_stat: {:?}",
            TimeStamp::physical_now(),
            self.load_meta_stat.meta_files_in,
            self.meta_len,
            self.collect_stat.bytes_in - self.collect_stat.bytes_out,
            cid.0,
            lst,
            cst,
            speed,
            total_take,
            self.load_meta_stat,
        );
        futures::future::ok(())
    }

    fn after_execution_finished<'a>(
        &'a mut self,
        cx: &'a mut AfterFinishCtx<'a>,
    ) -> impl Future<Output = Result<()>> + 'a {
        let now = Local::now();
        cx.comments += &format!(
            "start_time: {}\n",
            self.begin
                .map(|v| v.to_rfc3339())
                .as_deref()
                .unwrap_or("unknown")
        );
        cx.comments += &format!("end_time: {}\n", now.to_rfc3339());
        cx.comments += &format!(
            "taken: {}\n",
            self.begin.map(|v| now - v).unwrap_or(Duration::zero())
        );
        cx.comments += &format!("exec_by: {:?}\n", tikv_util::sys::hostname());
        cx.comments += &format!("load_stat: {:?}\n", self.load_stat);
        cx.comments += &format!("compact_stat: {:?}\n", self.compact_stat);
        cx.comments += &format!("load_meta_stat: {:?}\n", self.load_meta_stat);
        cx.comments += &format!("collect_stat: {:?}\n", self.collect_stat);

        println!("[{}] All compcations done", TimeStamp::physical_now(),);
        println!("{}", cx.comments);
        futures::future::ok(())
    }

    fn update_load_meta_stat(&mut self, stat: &LoadMetaStatistic) {
        self.load_meta_stat += stat.clone();
    }

    fn before_execution_started(&mut self, cx: BeforeStartCtx<'_>) {
        tracing_active_tree::init();

        self.begin = Some(Local::now());
        let sigusr1_handler = async {
            let mut signal = tokio::signal::unix::signal(SignalKind::user_defined1()).unwrap();
            while let Some(_) = signal.recv().await {
                let file_name = "/tmp/compact-sst.dump".to_owned();
                let res = async {
                    let mut file = tokio::fs::File::create(&file_name).await?;
                    file.write_all(&tracing_active_tree::layer::global().fmt_bytes())
                        .await
                }
                .await;
                match res {
                    Ok(_) => eprintln!("dumped to {}", file_name),
                    Err(err) => eprintln!("failed to dump because {}", err),
                }
            }
        };

        cx.async_rt.spawn(sigusr1_handler);
        self.meta_len = cx.est_meta_size;
    }

    fn update_collect_compaction_stat(&mut self, stat: &CollectCompactionStatistic) {
        self.collect_stat += stat.clone()
    }
}
