// Copyright 2023 TiKV Project Authors. Licensed under Apache-2.0.
//! This mod provides the ability of managing the temporary files generated by
//! log backup.

use std::{
    collections::HashMap,
    path::{Path, PathBuf},
    pin::Pin,
    sync::{
        atomic::{AtomicUsize, Ordering},
        Arc, Mutex as BlockMutex,
    },
    task::ready,
};

use futures::io::Cursor;
use kvproto::brpb::CompressionType;
use tikv_util::{config::ReadableSize, mpsc::Receiver};
use tokio::{
    fs::File as OsFile,
    io::{AsyncRead, AsyncWrite, AsyncWriteExt},
    sync::Mutex,
};

use crate::errors::{Error, Result};

pub struct Config {
    /// When the in memory bytes reaches this, start to flush files into disk at
    /// background.
    pub soft_max: usize,
    /// When the in memory bytes reaches this, abort the log backup task.
    pub hard_max: usize,
    /// The base directory for swapping out files.
    pub swap_files: PathBuf,
    /// The compression type used for compression.
    pub artificate_compression: CompressionType,
}

pub struct TempFilePool {
    cfg: Config,
    current: AtomicUsize,
    files: BlockMutex<FileSet>,
}

struct MemInner(Vec<u8>, PathBuf, Arc<TempFilePool>);

struct SwapOutInner {
    internal: OsFile,
}

#[derive(Clone)]
pub struct File {
    inst: Arc<Mutex<FileInstance>>,
    parent: Arc<TempFilePool>,
    // NOTE: should we make it a shared reference?
    path: PathBuf,
}

enum FileInstance {
    Mem(MemInner),
    SwapOut(SwapOutInner),
}

enum FileCursor {
    Mem(Vec<u8>, usize),
    SwapOut(OsFile),
}

enum FileCursorRef<'a> {
    Mem(Cursor<&'a [u8]>),
    SwapOut(&'a mut OsFile),
}

#[derive(Default)]
struct FileSet {
    items: HashMap<PathBuf, File>,
}

impl TempFilePool {
    pub fn new(cfg: Config) -> Self {
        Self {
            cfg,
            current: AtomicUsize::new(0usize),
            files: BlockMutex::default(),
        }
    }

    pub fn file(self: &Arc<Self>, p: &Path) -> File {
        let mut fs = self.files.lock().unwrap();
        fs.items
            .entry(p.to_owned())
            .or_insert_with(|| File::new_at(Arc::clone(self), p))
            .clone()
    }

    pub fn config(&self) -> &Config {
        &self.cfg
    }
}

impl File {
    fn new_at(parent: Arc<TempFilePool>, path: &Path) -> Self {
        let inner = MemInner(
            Vec::with_capacity(8126),
            path.to_owned(),
            Arc::clone(&parent),
        );
        let instance = FileInstance::Mem(inner);
        Self {
            inst: Arc::new(Mutex::new(instance)),
            parent,
            path: path.to_owned(),
        }
    }

    pub async fn append(&self, data: &[u8]) -> Result<()> {
        let mut inner = self.inst.lock().await;
        match &mut *inner {
            FileInstance::Mem(m) => {
                let mem_use = self.parent.current.fetch_add(data.len(), Ordering::SeqCst);
                if mem_use > self.parent.cfg.soft_max {
                    let mem_to_release = m.len();
                    *inner = FileInstance::SwapOut(m.swap_out().await?);
                    self.parent
                        .current
                        .fetch_sub(mem_to_release, Ordering::SeqCst);
                    return Ok(());
                }
                m.0.extend(data.iter());
            }
            FileInstance::SwapOut(o) => {
                o.internal.write(data).await?;
            }
        }
        Ok(())
    }

    pub async fn done(&self) -> Result<()> {
        let mut inner = self.inst.lock().await;
        match &mut *inner {
            FileInstance::Mem(_) => Ok(()),
            FileInstance::SwapOut(f) => f.internal.sync_data().await.map_err(From::from),
        }
    }

    pub fn path(&self) -> &Path {
        &self.path
    }

    pub fn read_content(&mut self) -> FileCursorRef<'_> {
        
    }
}

impl MemInner {
    fn len(&self) -> usize {
        self.0.len()
    }

    async fn swap_out(&self) -> Result<SwapOutInner> {
        let mut so = SwapOutInner::create_at(&self.2.cfg.swap_files.join(&self.1)).await?;
        so.internal.write_all(&self.0).await?;
        Ok(so)
    }
}

impl SwapOutInner {
    async fn create_at(p: &Path) -> Result<Self> {
        let file = OsFile::create(p).await?;
        Ok(Self { internal: file })
    }
}

impl AsyncRead for FileCursor {
    fn poll_read(
        mut self: Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
        buf: &mut tokio::io::ReadBuf<'_>,
    ) -> std::task::Poll<std::io::Result<()>> {
        match &mut *self {
            FileCursor::Mem(items, offset) => {
                let offset = *offset;
                if offset >= items.len() {
                    return Ok(()).into();
                }
                let rem = buf.remaining();
                let items_rem = items.len() - offset;
                let max_size = rem.min(items_rem);
                buf.put_slice(&items[offset..offset + max_size]);
                Ok(()).into()
            }
            FileCursor::SwapOut(f) => ready!(Pin::new(f).poll_read(cx, buf)).into(),
        }
    }
}

