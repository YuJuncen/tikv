// Copyright 2023 TiKV Project Authors. Licensed under Apache-2.0.
//! This mod provides the ability of managing the temporary files generated by
//! log backup.

use std::{
    collections::HashMap,
    path::{Path, PathBuf},
    pin::Pin,
    sync::{
        atomic::{AtomicUsize, Ordering},
        Arc, Mutex as BlockMutex,
    },
    task::ready,
};

use futures::{io::Cursor, Future, FutureExt};
use futures_io::SeekFrom;
use kvproto::brpb::CompressionType;
use tikv_util::{config::ReadableSize, mpsc::Receiver};
use tokio::{
    fs::File as OsFile,
    io::{AsyncRead, AsyncReadExt, AsyncSeekExt, AsyncWrite, AsyncWriteExt},
    pin,
    sync::Mutex,
};

use crate::errors::{Error, Result};

pub struct Config {
    /// When the in memory bytes reaches this, start to flush files into disk at
    /// background.
    pub soft_max: usize,
    /// When the in memory bytes reaches this, abort the log backup task.
    pub hard_max: usize,
    /// The base directory for swapping out files.
    pub swap_files: PathBuf,
    /// The compression type used for compression.
    pub artificate_compression: CompressionType,
}

pub struct TempFilePool {
    cfg: Config,
    current: AtomicUsize,
    files: BlockMutex<FileSet>,
}

struct MemInner(Vec<u8>, PathBuf, Arc<TempFilePool>);

struct SwapOutInner {
    internal: OsFile,
}

#[derive(Clone)]
pub struct File {
    inst: Arc<Mutex<FileInstance>>,
    parent: Arc<TempFilePool>,
    // NOTE: should we make it a shared reference?
    path: PathBuf,
}

enum FileInstance {
    Mem(MemInner),
    SwapOut(SwapOutInner),
}

pub struct FileCursor {
    file: File,
    status: FileCursorStatus,
}

enum FileCursorStatus {
    Mem(usize),
    SwapOut(OsFile),
}

#[derive(Default)]
struct FileSet {
    items: HashMap<PathBuf, File>,
}

impl TempFilePool {
    pub fn new(cfg: Config) -> Self {
        Self {
            cfg,
            current: AtomicUsize::new(0usize),
            files: BlockMutex::default(),
        }
    }

    pub fn file(self: &Arc<Self>, p: &Path) -> File {
        let mut fs = self.files.lock().unwrap();
        fs.items
            .entry(p.to_owned())
            .or_insert_with(|| File::new_at(Arc::clone(self), p))
            .clone()
    }

    pub fn config(&self) -> &Config {
        &self.cfg
    }
}

impl File {
    fn new_at(parent: Arc<TempFilePool>, path: &Path) -> Self {
        let inner = MemInner(
            Vec::with_capacity(8126),
            path.to_owned(),
            Arc::clone(&parent),
        );
        let instance = FileInstance::Mem(inner);
        Self {
            inst: Arc::new(Mutex::new(instance)),
            parent,
            path: path.to_owned(),
        }
    }

    pub async fn append(&self, data: &[u8]) -> Result<()> {
        let mut inner = self.inst.lock().await;
        match &mut *inner {
            FileInstance::Mem(m) => {
                let mem_use = self.parent.current.fetch_add(data.len(), Ordering::SeqCst);
                if mem_use > self.parent.cfg.soft_max {
                    let mem_to_release = m.len();
                    *inner = FileInstance::SwapOut(m.swap_out().await?);
                    self.parent
                        .current
                        .fetch_sub(mem_to_release, Ordering::SeqCst);
                    return Ok(());
                }
                m.0.extend(data.iter());
            }
            FileInstance::SwapOut(o) => {
                o.internal.write(data).await?;
            }
        }
        Ok(())
    }

    pub async fn done(&self) -> Result<()> {
        let mut inner = self.inst.lock().await;
        match &mut *inner {
            FileInstance::Mem(_) => Ok(()),
            FileInstance::SwapOut(f) => f.internal.sync_data().await.map_err(From::from),
        }
    }

    pub fn path(&self) -> &Path {
        &self.path
    }

    pub async fn take_content(&mut self) -> Result<FileCursor> {
        todo!()
    }
}

impl MemInner {
    fn len(&self) -> usize {
        self.0.len()
    }

    async fn swap_out(&self) -> Result<SwapOutInner> {
        let mut so = SwapOutInner::create_at(&self.2.cfg.swap_files.join(&self.1)).await?;
        so.internal.write_all(&self.0).await?;
        Ok(so)
    }
}

impl SwapOutInner {
    async fn create_at(p: &Path) -> Result<Self> {
        let file = OsFile::create(p).await?;
        Ok(Self { internal: file })
    }
}

impl FileCursor {
    pub async fn len(&self) -> Result<u64> {
        match self {
            FileCursor::Mem(v, _) => Ok(v.len() as _),
            FileCursor::SwapOut(f) => {
                let stat = f.metadata().await?;
                Ok(stat.len())
            }
        }
    }

    pub async fn fetch(&mut self, buf: &mut [u8]) -> Result<usize> {
        let mut inst = self.file.inst.lock().await;
        loop {
            match (&mut *inst, &mut self.status) {
                (FileInstance::Mem(ref mut m), FileCursorStatus::Mem(offset)) => {
                    if *offset >= m.0.len() {
                        return Ok(0);
                    }
                    let rem = buf.len();
                    let items_rem = m.0.len() - *offset;
                    let max_size = rem.min(items_rem);
                    (buf[..max_size]).copy_from_slice(&m.0[*offset..*offset + max_size]);
                    *offset += max_size;
                    return Ok(max_size);
                }
                (FileInstance::SwapOut(ref mut f), FileCursorStatus::Mem(offset)) => {
                    let mut new_fd = f.internal.try_clone().await?;
                    new_fd.seek(SeekFrom::Start(*offset as _)).await?;
                    self.status = FileCursorStatus::SwapOut(new_fd);
                }
                (FileInstance::SwapOut(_), FileCursorStatus::SwapOut(ref mut f)) => {
                    return f.read(buf).await.map_err(From::from);
                }
            }
        }
    }
}

impl AsyncRead for FileCursor {
    fn poll_read(
        mut self: Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
        buf: &mut tokio::io::ReadBuf<'_>,
    ) -> std::task::Poll<std::io::Result<()>> {
        todo!()
    }
}

#[cfg(test)]
mod test {
    fn test_read() {}
}
